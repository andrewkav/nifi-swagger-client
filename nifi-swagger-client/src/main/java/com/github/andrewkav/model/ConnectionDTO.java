/*
 * NiFi Rest Api
 * The Rest Api provides programmatic access to command and control a NiFi instance in real time. Start and                                              stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.
 *
 * The version of the OpenAPI document: 1.9.2
 * Contact: dev@nifi.apache.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.github.andrewkav.model;

import java.util.Objects;
import java.util.Arrays;
import com.github.andrewkav.model.ConnectableDTO;
import com.github.andrewkav.model.PositionDTO;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * ConnectionDTO
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2019-07-24T10:52:32.266Z[GMT]")
public class ConnectionDTO {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_VERSIONED_COMPONENT_ID = "versionedComponentId";
  @SerializedName(SERIALIZED_NAME_VERSIONED_COMPONENT_ID)
  private String versionedComponentId;

  public static final String SERIALIZED_NAME_PARENT_GROUP_ID = "parentGroupId";
  @SerializedName(SERIALIZED_NAME_PARENT_GROUP_ID)
  private String parentGroupId;

  public static final String SERIALIZED_NAME_POSITION = "position";
  @SerializedName(SERIALIZED_NAME_POSITION)
  private PositionDTO position = null;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private ConnectableDTO source = null;

  public static final String SERIALIZED_NAME_DESTINATION = "destination";
  @SerializedName(SERIALIZED_NAME_DESTINATION)
  private ConnectableDTO destination = null;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_LABEL_INDEX = "labelIndex";
  @SerializedName(SERIALIZED_NAME_LABEL_INDEX)
  private Integer labelIndex;

  public static final String SERIALIZED_NAME_GETZ_INDEX = "getzIndex";
  @SerializedName(SERIALIZED_NAME_GETZ_INDEX)
  private Long getzIndex;

  public static final String SERIALIZED_NAME_SELECTED_RELATIONSHIPS = "selectedRelationships";
  @SerializedName(SERIALIZED_NAME_SELECTED_RELATIONSHIPS)
  private List<String> selectedRelationships = new ArrayList<String>();

  public static final String SERIALIZED_NAME_AVAILABLE_RELATIONSHIPS = "availableRelationships";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_RELATIONSHIPS)
  private List<String> availableRelationships = new ArrayList<String>();

  public static final String SERIALIZED_NAME_BACK_PRESSURE_OBJECT_THRESHOLD = "backPressureObjectThreshold";
  @SerializedName(SERIALIZED_NAME_BACK_PRESSURE_OBJECT_THRESHOLD)
  private Long backPressureObjectThreshold;

  public static final String SERIALIZED_NAME_BACK_PRESSURE_DATA_SIZE_THRESHOLD = "backPressureDataSizeThreshold";
  @SerializedName(SERIALIZED_NAME_BACK_PRESSURE_DATA_SIZE_THRESHOLD)
  private String backPressureDataSizeThreshold;

  public static final String SERIALIZED_NAME_FLOW_FILE_EXPIRATION = "flowFileExpiration";
  @SerializedName(SERIALIZED_NAME_FLOW_FILE_EXPIRATION)
  private String flowFileExpiration;

  public static final String SERIALIZED_NAME_PRIORITIZERS = "prioritizers";
  @SerializedName(SERIALIZED_NAME_PRIORITIZERS)
  private List<String> prioritizers = new ArrayList<String>();

  public static final String SERIALIZED_NAME_BENDS = "bends";
  @SerializedName(SERIALIZED_NAME_BENDS)
  private List<PositionDTO> bends = new ArrayList<PositionDTO>();

  /**
   * How to load balance the data in this Connection across the nodes in the cluster.
   */
  @JsonAdapter(LoadBalanceStrategyEnum.Adapter.class)
  public enum LoadBalanceStrategyEnum {
    DO_NOT_LOAD_BALANCE("DO_NOT_LOAD_BALANCE"),
    
    PARTITION_BY_ATTRIBUTE("PARTITION_BY_ATTRIBUTE"),
    
    ROUND_ROBIN("ROUND_ROBIN"),
    
    SINGLE_NODE("SINGLE_NODE");

    private String value;

    LoadBalanceStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LoadBalanceStrategyEnum fromValue(String value) {
      for (LoadBalanceStrategyEnum b : LoadBalanceStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LoadBalanceStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LoadBalanceStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LoadBalanceStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return LoadBalanceStrategyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_LOAD_BALANCE_STRATEGY = "loadBalanceStrategy";
  @SerializedName(SERIALIZED_NAME_LOAD_BALANCE_STRATEGY)
  private LoadBalanceStrategyEnum loadBalanceStrategy;

  public static final String SERIALIZED_NAME_LOAD_BALANCE_PARTITION_ATTRIBUTE = "loadBalancePartitionAttribute";
  @SerializedName(SERIALIZED_NAME_LOAD_BALANCE_PARTITION_ATTRIBUTE)
  private String loadBalancePartitionAttribute;

  /**
   * Whether or not data should be compressed when being transferred between nodes in the cluster.
   */
  @JsonAdapter(LoadBalanceCompressionEnum.Adapter.class)
  public enum LoadBalanceCompressionEnum {
    DO_NOT_COMPRESS("DO_NOT_COMPRESS"),
    
    COMPRESS_ATTRIBUTES_ONLY("COMPRESS_ATTRIBUTES_ONLY"),
    
    COMPRESS_ATTRIBUTES_AND_CONTENT("COMPRESS_ATTRIBUTES_AND_CONTENT");

    private String value;

    LoadBalanceCompressionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LoadBalanceCompressionEnum fromValue(String value) {
      for (LoadBalanceCompressionEnum b : LoadBalanceCompressionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LoadBalanceCompressionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LoadBalanceCompressionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LoadBalanceCompressionEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return LoadBalanceCompressionEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_LOAD_BALANCE_COMPRESSION = "loadBalanceCompression";
  @SerializedName(SERIALIZED_NAME_LOAD_BALANCE_COMPRESSION)
  private LoadBalanceCompressionEnum loadBalanceCompression;

  /**
   * The current status of the Connection&#39;s Load Balancing Activities. Status can indicate that Load Balancing is not configured for the connection, that Load Balancing is configured but inactive (not currently transferring data to another node), or that Load Balancing is configured and actively transferring data to another node.
   */
  @JsonAdapter(LoadBalanceStatusEnum.Adapter.class)
  public enum LoadBalanceStatusEnum {
    NOT_CONFIGURED("LOAD_BALANCE_NOT_CONFIGURED"),
    
    INACTIVE("LOAD_BALANCE_INACTIVE"),
    
    ACTIVE("LOAD_BALANCE_ACTIVE");

    private String value;

    LoadBalanceStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LoadBalanceStatusEnum fromValue(String value) {
      for (LoadBalanceStatusEnum b : LoadBalanceStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LoadBalanceStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LoadBalanceStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LoadBalanceStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return LoadBalanceStatusEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_LOAD_BALANCE_STATUS = "loadBalanceStatus";
  @SerializedName(SERIALIZED_NAME_LOAD_BALANCE_STATUS)
  private LoadBalanceStatusEnum loadBalanceStatus;

  public ConnectionDTO id(String id) {
    this.id = id;
    return this;
  }

   /**
   * The id of the component.
   * @return id
  **/
  @ApiModelProperty(value = "The id of the component.")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public ConnectionDTO versionedComponentId(String versionedComponentId) {
    this.versionedComponentId = versionedComponentId;
    return this;
  }

   /**
   * The ID of the corresponding component that is under version control
   * @return versionedComponentId
  **/
  @ApiModelProperty(value = "The ID of the corresponding component that is under version control")
  public String getVersionedComponentId() {
    return versionedComponentId;
  }

  public void setVersionedComponentId(String versionedComponentId) {
    this.versionedComponentId = versionedComponentId;
  }

  public ConnectionDTO parentGroupId(String parentGroupId) {
    this.parentGroupId = parentGroupId;
    return this;
  }

   /**
   * The id of parent process group of this component if applicable.
   * @return parentGroupId
  **/
  @ApiModelProperty(value = "The id of parent process group of this component if applicable.")
  public String getParentGroupId() {
    return parentGroupId;
  }

  public void setParentGroupId(String parentGroupId) {
    this.parentGroupId = parentGroupId;
  }

  public ConnectionDTO position(PositionDTO position) {
    this.position = position;
    return this;
  }

   /**
   * Get position
   * @return position
  **/
  @ApiModelProperty(value = "")
  public PositionDTO getPosition() {
    return position;
  }

  public void setPosition(PositionDTO position) {
    this.position = position;
  }

  public ConnectionDTO source(ConnectableDTO source) {
    this.source = source;
    return this;
  }

   /**
   * Get source
   * @return source
  **/
  @ApiModelProperty(value = "")
  public ConnectableDTO getSource() {
    return source;
  }

  public void setSource(ConnectableDTO source) {
    this.source = source;
  }

  public ConnectionDTO destination(ConnectableDTO destination) {
    this.destination = destination;
    return this;
  }

   /**
   * Get destination
   * @return destination
  **/
  @ApiModelProperty(value = "")
  public ConnectableDTO getDestination() {
    return destination;
  }

  public void setDestination(ConnectableDTO destination) {
    this.destination = destination;
  }

  public ConnectionDTO name(String name) {
    this.name = name;
    return this;
  }

   /**
   * The name of the connection.
   * @return name
  **/
  @ApiModelProperty(value = "The name of the connection.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public ConnectionDTO labelIndex(Integer labelIndex) {
    this.labelIndex = labelIndex;
    return this;
  }

   /**
   * The index of the bend point where to place the connection label.
   * @return labelIndex
  **/
  @ApiModelProperty(value = "The index of the bend point where to place the connection label.")
  public Integer getLabelIndex() {
    return labelIndex;
  }

  public void setLabelIndex(Integer labelIndex) {
    this.labelIndex = labelIndex;
  }

  public ConnectionDTO getzIndex(Long getzIndex) {
    this.getzIndex = getzIndex;
    return this;
  }

   /**
   * The z index of the connection.
   * @return getzIndex
  **/
  @ApiModelProperty(value = "The z index of the connection.")
  public Long getGetzIndex() {
    return getzIndex;
  }

  public void setGetzIndex(Long getzIndex) {
    this.getzIndex = getzIndex;
  }

  public ConnectionDTO selectedRelationships(List<String> selectedRelationships) {
    this.selectedRelationships = selectedRelationships;
    return this;
  }

  public ConnectionDTO addSelectedRelationshipsItem(String selectedRelationshipsItem) {
    if (this.selectedRelationships == null) {
      this.selectedRelationships = new ArrayList<String>();
    }
    this.selectedRelationships.add(selectedRelationshipsItem);
    return this;
  }

   /**
   * The selected relationship that comprise the connection.
   * @return selectedRelationships
  **/
  @ApiModelProperty(value = "The selected relationship that comprise the connection.")
  public List<String> getSelectedRelationships() {
    return selectedRelationships;
  }

  public void setSelectedRelationships(List<String> selectedRelationships) {
    this.selectedRelationships = selectedRelationships;
  }

   /**
   * The relationships that the source of the connection currently supports.
   * @return availableRelationships
  **/
  @ApiModelProperty(value = "The relationships that the source of the connection currently supports.")
  public List<String> getAvailableRelationships() {
    return availableRelationships;
  }

  public ConnectionDTO backPressureObjectThreshold(Long backPressureObjectThreshold) {
    this.backPressureObjectThreshold = backPressureObjectThreshold;
    return this;
  }

   /**
   * The object count threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won&#39;t impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.
   * @return backPressureObjectThreshold
  **/
  @ApiModelProperty(value = "The object count threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won't impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.")
  public Long getBackPressureObjectThreshold() {
    return backPressureObjectThreshold;
  }

  public void setBackPressureObjectThreshold(Long backPressureObjectThreshold) {
    this.backPressureObjectThreshold = backPressureObjectThreshold;
  }

  public ConnectionDTO backPressureDataSizeThreshold(String backPressureDataSizeThreshold) {
    this.backPressureDataSizeThreshold = backPressureDataSizeThreshold;
    return this;
  }

   /**
   * The object data size threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won&#39;t impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.
   * @return backPressureDataSizeThreshold
  **/
  @ApiModelProperty(value = "The object data size threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won't impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.")
  public String getBackPressureDataSizeThreshold() {
    return backPressureDataSizeThreshold;
  }

  public void setBackPressureDataSizeThreshold(String backPressureDataSizeThreshold) {
    this.backPressureDataSizeThreshold = backPressureDataSizeThreshold;
  }

  public ConnectionDTO flowFileExpiration(String flowFileExpiration) {
    this.flowFileExpiration = flowFileExpiration;
    return this;
  }

   /**
   * The amount of time a flow file may be in the flow before it will be automatically aged out of the flow. Once a flow file reaches this age it will be terminated from the flow the next time a processor attempts to start work on it.
   * @return flowFileExpiration
  **/
  @ApiModelProperty(value = "The amount of time a flow file may be in the flow before it will be automatically aged out of the flow. Once a flow file reaches this age it will be terminated from the flow the next time a processor attempts to start work on it.")
  public String getFlowFileExpiration() {
    return flowFileExpiration;
  }

  public void setFlowFileExpiration(String flowFileExpiration) {
    this.flowFileExpiration = flowFileExpiration;
  }

  public ConnectionDTO prioritizers(List<String> prioritizers) {
    this.prioritizers = prioritizers;
    return this;
  }

  public ConnectionDTO addPrioritizersItem(String prioritizersItem) {
    if (this.prioritizers == null) {
      this.prioritizers = new ArrayList<String>();
    }
    this.prioritizers.add(prioritizersItem);
    return this;
  }

   /**
   * The comparators used to prioritize the queue.
   * @return prioritizers
  **/
  @ApiModelProperty(value = "The comparators used to prioritize the queue.")
  public List<String> getPrioritizers() {
    return prioritizers;
  }

  public void setPrioritizers(List<String> prioritizers) {
    this.prioritizers = prioritizers;
  }

  public ConnectionDTO bends(List<PositionDTO> bends) {
    this.bends = bends;
    return this;
  }

  public ConnectionDTO addBendsItem(PositionDTO bendsItem) {
    if (this.bends == null) {
      this.bends = new ArrayList<PositionDTO>();
    }
    this.bends.add(bendsItem);
    return this;
  }

   /**
   * The bend points on the connection.
   * @return bends
  **/
  @ApiModelProperty(value = "The bend points on the connection.")
  public List<PositionDTO> getBends() {
    return bends;
  }

  public void setBends(List<PositionDTO> bends) {
    this.bends = bends;
  }

  public ConnectionDTO loadBalanceStrategy(LoadBalanceStrategyEnum loadBalanceStrategy) {
    this.loadBalanceStrategy = loadBalanceStrategy;
    return this;
  }

   /**
   * How to load balance the data in this Connection across the nodes in the cluster.
   * @return loadBalanceStrategy
  **/
  @ApiModelProperty(value = "How to load balance the data in this Connection across the nodes in the cluster.")
  public LoadBalanceStrategyEnum getLoadBalanceStrategy() {
    return loadBalanceStrategy;
  }

  public void setLoadBalanceStrategy(LoadBalanceStrategyEnum loadBalanceStrategy) {
    this.loadBalanceStrategy = loadBalanceStrategy;
  }

  public ConnectionDTO loadBalancePartitionAttribute(String loadBalancePartitionAttribute) {
    this.loadBalancePartitionAttribute = loadBalancePartitionAttribute;
    return this;
  }

   /**
   * The FlowFile Attribute to use for determining which node a FlowFile will go to if the Load Balancing Strategy is set to PARTITION_BY_ATTRIBUTE
   * @return loadBalancePartitionAttribute
  **/
  @ApiModelProperty(value = "The FlowFile Attribute to use for determining which node a FlowFile will go to if the Load Balancing Strategy is set to PARTITION_BY_ATTRIBUTE")
  public String getLoadBalancePartitionAttribute() {
    return loadBalancePartitionAttribute;
  }

  public void setLoadBalancePartitionAttribute(String loadBalancePartitionAttribute) {
    this.loadBalancePartitionAttribute = loadBalancePartitionAttribute;
  }

  public ConnectionDTO loadBalanceCompression(LoadBalanceCompressionEnum loadBalanceCompression) {
    this.loadBalanceCompression = loadBalanceCompression;
    return this;
  }

   /**
   * Whether or not data should be compressed when being transferred between nodes in the cluster.
   * @return loadBalanceCompression
  **/
  @ApiModelProperty(value = "Whether or not data should be compressed when being transferred between nodes in the cluster.")
  public LoadBalanceCompressionEnum getLoadBalanceCompression() {
    return loadBalanceCompression;
  }

  public void setLoadBalanceCompression(LoadBalanceCompressionEnum loadBalanceCompression) {
    this.loadBalanceCompression = loadBalanceCompression;
  }

   /**
   * The current status of the Connection&#39;s Load Balancing Activities. Status can indicate that Load Balancing is not configured for the connection, that Load Balancing is configured but inactive (not currently transferring data to another node), or that Load Balancing is configured and actively transferring data to another node.
   * @return loadBalanceStatus
  **/
  @ApiModelProperty(value = "The current status of the Connection's Load Balancing Activities. Status can indicate that Load Balancing is not configured for the connection, that Load Balancing is configured but inactive (not currently transferring data to another node), or that Load Balancing is configured and actively transferring data to another node.")
  public LoadBalanceStatusEnum getLoadBalanceStatus() {
    return loadBalanceStatus;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConnectionDTO connectionDTO = (ConnectionDTO) o;
    return Objects.equals(this.id, connectionDTO.id) &&
        Objects.equals(this.versionedComponentId, connectionDTO.versionedComponentId) &&
        Objects.equals(this.parentGroupId, connectionDTO.parentGroupId) &&
        Objects.equals(this.position, connectionDTO.position) &&
        Objects.equals(this.source, connectionDTO.source) &&
        Objects.equals(this.destination, connectionDTO.destination) &&
        Objects.equals(this.name, connectionDTO.name) &&
        Objects.equals(this.labelIndex, connectionDTO.labelIndex) &&
        Objects.equals(this.getzIndex, connectionDTO.getzIndex) &&
        Objects.equals(this.selectedRelationships, connectionDTO.selectedRelationships) &&
        Objects.equals(this.availableRelationships, connectionDTO.availableRelationships) &&
        Objects.equals(this.backPressureObjectThreshold, connectionDTO.backPressureObjectThreshold) &&
        Objects.equals(this.backPressureDataSizeThreshold, connectionDTO.backPressureDataSizeThreshold) &&
        Objects.equals(this.flowFileExpiration, connectionDTO.flowFileExpiration) &&
        Objects.equals(this.prioritizers, connectionDTO.prioritizers) &&
        Objects.equals(this.bends, connectionDTO.bends) &&
        Objects.equals(this.loadBalanceStrategy, connectionDTO.loadBalanceStrategy) &&
        Objects.equals(this.loadBalancePartitionAttribute, connectionDTO.loadBalancePartitionAttribute) &&
        Objects.equals(this.loadBalanceCompression, connectionDTO.loadBalanceCompression) &&
        Objects.equals(this.loadBalanceStatus, connectionDTO.loadBalanceStatus);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, versionedComponentId, parentGroupId, position, source, destination, name, labelIndex, getzIndex, selectedRelationships, availableRelationships, backPressureObjectThreshold, backPressureDataSizeThreshold, flowFileExpiration, prioritizers, bends, loadBalanceStrategy, loadBalancePartitionAttribute, loadBalanceCompression, loadBalanceStatus);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConnectionDTO {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    versionedComponentId: ").append(toIndentedString(versionedComponentId)).append("\n");
    sb.append("    parentGroupId: ").append(toIndentedString(parentGroupId)).append("\n");
    sb.append("    position: ").append(toIndentedString(position)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    destination: ").append(toIndentedString(destination)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    labelIndex: ").append(toIndentedString(labelIndex)).append("\n");
    sb.append("    getzIndex: ").append(toIndentedString(getzIndex)).append("\n");
    sb.append("    selectedRelationships: ").append(toIndentedString(selectedRelationships)).append("\n");
    sb.append("    availableRelationships: ").append(toIndentedString(availableRelationships)).append("\n");
    sb.append("    backPressureObjectThreshold: ").append(toIndentedString(backPressureObjectThreshold)).append("\n");
    sb.append("    backPressureDataSizeThreshold: ").append(toIndentedString(backPressureDataSizeThreshold)).append("\n");
    sb.append("    flowFileExpiration: ").append(toIndentedString(flowFileExpiration)).append("\n");
    sb.append("    prioritizers: ").append(toIndentedString(prioritizers)).append("\n");
    sb.append("    bends: ").append(toIndentedString(bends)).append("\n");
    sb.append("    loadBalanceStrategy: ").append(toIndentedString(loadBalanceStrategy)).append("\n");
    sb.append("    loadBalancePartitionAttribute: ").append(toIndentedString(loadBalancePartitionAttribute)).append("\n");
    sb.append("    loadBalanceCompression: ").append(toIndentedString(loadBalanceCompression)).append("\n");
    sb.append("    loadBalanceStatus: ").append(toIndentedString(loadBalanceStatus)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

